<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust Lambda Hello World Tests | MillerJAM Site</title><meta name=keywords content><meta name=description content="This is my third and final post in this series about getting started with writing Lambda&rsquo;s in Rust. So far, we have created a new lambda, cross compiled it to run in the AWS Lamdba environment, and added some logging so we can debug issues and see how the code is executing.
In this final post, we will add tests and setup Github Actions to verify these test on any Pull Request."><meta name=author content><link rel=canonical href=http://millerjam.github.io/posts/rust-lambda-hello-world-tests/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://millerjam.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://millerjam.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://millerjam.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://millerjam.github.io/apple-touch-icon.png><link rel=mask-icon href=http://millerjam.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Rust Lambda Hello World Tests"><meta property="og:description" content="This is my third and final post in this series about getting started with writing Lambda&rsquo;s in Rust. So far, we have created a new lambda, cross compiled it to run in the AWS Lamdba environment, and added some logging so we can debug issues and see how the code is executing.
In this final post, we will add tests and setup Github Actions to verify these test on any Pull Request."><meta property="og:type" content="article"><meta property="og:url" content="http://millerjam.github.io/posts/rust-lambda-hello-world-tests/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-27T09:09:17-04:00"><meta property="article:modified_time" content="2022-03-27T09:09:17-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Lambda Hello World Tests"><meta name=twitter:description content="This is my third and final post in this series about getting started with writing Lambda&rsquo;s in Rust. So far, we have created a new lambda, cross compiled it to run in the AWS Lamdba environment, and added some logging so we can debug issues and see how the code is executing.
In this final post, we will add tests and setup Github Actions to verify these test on any Pull Request."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://millerjam.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Rust Lambda Hello World Tests","item":"http://millerjam.github.io/posts/rust-lambda-hello-world-tests/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Lambda Hello World Tests","name":"Rust Lambda Hello World Tests","description":"This is my third and final post in this series about getting started with writing Lambda\u0026rsquo;s in Rust. So far, we have created a new lambda, cross compiled it to run in the AWS Lamdba environment, and added some logging so we can debug issues and see how the code is executing.\nIn this final post, we will add tests and setup Github Actions to verify these test on any Pull Request.","keywords":[],"articleBody":"This is my third and final post in this series about getting started with writing Lambda’s in Rust. So far, we have created a new lambda, cross compiled it to run in the AWS Lamdba environment, and added some logging so we can debug issues and see how the code is executing.\nIn this final post, we will add tests and setup Github Actions to verify these test on any Pull Request.\n You can check out the previous posts here\n https://millerjam.github.io/posts/rust-lambda-hello-world/ https://millerjam.github.io/posts/rust-lambda-hello-world-logging/    Let’s add a test Now that we have some code and logging in place, there is one final thing I want to cover before we could consider adding more code. We should quickly look at how to test this code.\nThe AWS Lambda Rust Runtime makes it easy to test your handler code. When we look at the existing main() method we see that we are just registering our handler function func with the lambda_runtime.\nThis forces a nice decoupling between the code wiring up the lambda environment, and the business logic in the handler function.\nBusiness logic In the “hello world” example, the business logic is as follows:\n Check for a “firstName” value in the incoming event. If firstName is found, return “Hello, [firstName]!” If firstName is NOT found, return “Hello, world!”  Writing a test The easiest way to add test code, is to create the tests in the same file as the function we are trying to test.\nIn our example we will add a new test directly in the src/main.rs file.\nHere is the code we will add as the bottom of the file\nmain.rs\n#[cfg(test)] mod tests {  use super::*;  use lambda_runtime::Context;   #[tokio::test]  async fn test_func() {  let context = Context::default();  let payload = json!({\"firstName\": \"James\"});  let event = LambdaEvent { payload, context };  let result = func(event).await.unwrap();  assert_eq!(result[\"message\"], \"Hello, James!\");  } } You may notice that we are using #[tokio::test] and that the test itself is marked async, this is because the lambda rust runtime is using the tokio framework and when testing async function we need to using these constructs.\nFirst, we create the test Event using a default Context, and a JSON event with the proper field. Once we have created our test event, we are able to use that as the payload to call our function func(event). We use the await.unwrap() to get the result since our handler method func is an async function.\nThe test_func itself is a “happy path” test, verifying that we will get the expected output when the “firstName” field is found in the event. The final step of the test is to assert that the returned value matches the expected “Hello, James!”\nAdding a second test Now that we covered the “happy path” logic, we should add one more test to cover the case when “firstName” is not found\nIn the same mod test block, we can add a second test.\n#[tokio::test]  async fn test_func_bad_request() {  let context = Context::default();  let payload = json!({\"something\": \"wrong\"});  let event = LambdaEvent { payload, context };  let result = func(event).await.unwrap();  assert_eq!(result[\"message\"], \"Hello, world!\");  } This test follows the same format as the previous, with the difference being the payload is updates with different JSON value. We expect that the handle will return “Hello, world!” in this case.\nRunning test Now that we have created some tests, lets run them with cargo\ncargo test We should get output like this\nrunning 2 tests test tests::test_func_bad_request ... ok test tests::test_func ... ok Success! We can see that cargo found the 2 tests, and both are passing.\nAutomating test with Github Actions Now that we can run tests locally, it would be nice to have them running automatically when we create a new PR for our project.\nAdding github actions This is really easy to setup, using actions-rs.\nThis project provides a toolkit of GitHub Action for Rust projects.\nWe need to create a rust.yml file in .github/workflows/rust.yml\nThe yaml file will contain “jobs” for the cargo commands check, test, fmt, and clippy. This will make sure that all PRs made against our repo, are properly formatted, have passing test, and passing all standard rust linting checks.\nThe entire file is here https://github.com/millerjam/rust_lambda_hello_world/blob/main/.github/workflows/rust.yml\nOne you have committed this file into your github repo, you will see it populated in the “Action” tab\nPassing PRs will show a green check, and if any of the checks fail the PR will be marked as failed. And selecting the failed action will show the 4 jobs and which has failed\nConclusions Now, we have a completed “hello world” lambda example. We created:\n An hello world lambda function Cross compile the lambda Deployed it into AWS Added logging Added tests And finally, added continuous integration with GitHub Actions  Final GitHub Project You can reference the complete project here in my github repo https://github.com/millerjam/rust_lambda_hello_world\n","wordCount":"808","inLanguage":"en","datePublished":"2022-03-27T09:09:17-04:00","dateModified":"2022-03-27T09:09:17-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://millerjam.github.io/posts/rust-lambda-hello-world-tests/"},"publisher":{"@type":"Organization","name":"MillerJAM Site","logo":{"@type":"ImageObject","url":"http://millerjam.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://millerjam.github.io/ accesskey=h title="MillerJAM Site (Alt + H)">MillerJAM Site</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Rust Lambda Hello World Tests</h1><div class=post-meta><span title="2022-03-27 09:09:17 -0400 -0400">March 27, 2022</span>&nbsp;·&nbsp;4 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#lets-add-a-test aria-label="Let&amp;rsquo;s add a test">Let&rsquo;s add a test</a><ul><li><a href=#business-logic aria-label="Business logic">Business logic</a></li></ul></li><li><a href=#writing-a-test aria-label="Writing a test">Writing a test</a></li><li><a href=#adding-a-second-test aria-label="Adding a second test">Adding a second test</a></li><li><a href=#running-test aria-label="Running test">Running test</a></li><li><a href=#automating-test-with-github-actions aria-label="Automating test with Github Actions">Automating test with Github Actions</a><ul><li><a href=#adding-github-actions aria-label="Adding github actions">Adding github actions</a></li></ul></li><li><a href=#conclusions aria-label=Conclusions>Conclusions</a><ul><ul><li><a href=#final-github-project aria-label="Final GitHub Project">Final GitHub Project</a></li></ul></ul></li></ul></div></details></div><div class=post-content><p>This is my third and final post in this series about getting started with writing Lambda&rsquo;s in Rust. So far, we have created a new lambda, cross compiled it to run in the AWS Lamdba environment, and added some logging so we can debug issues and see how the code is executing.</p><p>In this final post, we will add tests and setup Github Actions to verify these test on any Pull Request.</p><blockquote><p>You can check out the previous posts here</p><ul><li><a href=https://millerjam.github.io/posts/rust-lambda-hello-world/>https://millerjam.github.io/posts/rust-lambda-hello-world/</a></li><li><a href=https://millerjam.github.io/posts/rust-lambda-hello-world-logging/>https://millerjam.github.io/posts/rust-lambda-hello-world-logging/</a></li></ul></blockquote><hr><h2 id=lets-add-a-test>Let&rsquo;s add a test<a hidden class=anchor aria-hidden=true href=#lets-add-a-test>#</a></h2><p>Now that we have some code and logging in place, there is one final thing I want to cover before we could consider adding more code. We should quickly look at how to test this code.</p><p>The <a href=https://github.com/awslabs/aws-lambda-rust-runtime>AWS Lambda Rust Runtime</a> makes it easy to test your handler code. When we look at the existing <a href=https://github.com/millerjam/rust_lambda_hello_world/blob/dc13198be3c2520d41cfd91dd87d2a3139d5b9c2/src/main.rs#L7-L12><code>main()</code> method</a> we see that we are just registering our handler function <code>func</code> with the <code>lambda_runtime</code>.</p><p>This forces a nice decoupling between the code wiring up the lambda environment, and the business logic in the handler function.</p><h3 id=business-logic>Business logic<a hidden class=anchor aria-hidden=true href=#business-logic>#</a></h3><p>In the &ldquo;hello world&rdquo; example, the business logic is as follows:</p><ol><li>Check for a &ldquo;firstName&rdquo; value in the incoming event.</li><li>If firstName is found, return &ldquo;Hello, [firstName]!&rdquo;</li><li>If firstName is NOT found, return &ldquo;Hello, world!&rdquo;</li></ol><h2 id=writing-a-test>Writing a test<a hidden class=anchor aria-hidden=true href=#writing-a-test>#</a></h2><p>The easiest way to add test code, is to create the tests in the same file as the function we are trying to test.</p><p>In our example we will add a new test directly in the <code>src/main.rs</code> file.</p><p>Here is the code we will add as the bottom of the file</p><p><code>main.rs</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> lambda_runtime::Context;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tokio::test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> context <span style=color:#f92672>=</span> Context::default();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> payload <span style=color:#f92672>=</span> json<span style=color:#f92672>!</span>({<span style=color:#e6db74>&#34;firstName&#34;</span>: <span style=color:#e6db74>&#34;James&#34;</span>});
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> event <span style=color:#f92672>=</span> LambdaEvent { payload, context };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> func(event).<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>        assert_eq!(result[<span style=color:#e6db74>&#34;message&#34;</span>], <span style=color:#e6db74>&#34;Hello, James!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You may notice that we are using <code>#[tokio::test]</code> and that the test itself is marked <code>async</code>, this is because the lambda rust runtime is using the tokio framework and when testing async function we need to using these constructs.</p><p>First, we create the test Event using a default <code>Context</code>, and a JSON event with the proper field. Once we have created our test <code>event</code>, we are able to use that as the payload to call our function <code>func(event)</code>. We use the <code>await.unwrap()</code> to get the result since our handler method <code>func</code> is an async function.</p><p>The <code>test_func</code> itself is a &ldquo;happy path&rdquo; test, verifying that we will get the expected output when the &ldquo;firstName&rdquo; field is found in the event. The final step of the test is to assert that the returned value matches the expected &ldquo;Hello, James!&rdquo;</p><h2 id=adding-a-second-test>Adding a second test<a hidden class=anchor aria-hidden=true href=#adding-a-second-test>#</a></h2><p>Now that we covered the &ldquo;happy path&rdquo; logic, we should add one more test to cover the case when &ldquo;firstName&rdquo; is not found</p><p>In the same <code>mod test</code> block, we can add a second test.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[tokio::test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_func_bad_request</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> context <span style=color:#f92672>=</span> Context::default();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> payload <span style=color:#f92672>=</span> json<span style=color:#f92672>!</span>({<span style=color:#e6db74>&#34;something&#34;</span>: <span style=color:#e6db74>&#34;wrong&#34;</span>});
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> event <span style=color:#f92672>=</span> LambdaEvent { payload, context };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> func(event).<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>        assert_eq!(result[<span style=color:#e6db74>&#34;message&#34;</span>], <span style=color:#e6db74>&#34;Hello, world!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>This test follows the same format as the previous, with the difference being the <code>payload</code> is updates with different JSON value. We expect that the handle will return &ldquo;Hello, world!&rdquo; in this case.</p><h2 id=running-test>Running test<a hidden class=anchor aria-hidden=true href=#running-test>#</a></h2><p>Now that we have created some tests, lets run them with cargo</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo test
</span></span></code></pre></div><p>We should get output like this</p><pre tabindex=0><code>running 2 tests
test tests::test_func_bad_request ... ok
test tests::test_func ... ok
</code></pre><p>Success! We can see that cargo found the 2 tests, and both are passing.</p><h2 id=automating-test-with-github-actions>Automating test with Github Actions<a hidden class=anchor aria-hidden=true href=#automating-test-with-github-actions>#</a></h2><p>Now that we can run tests locally, it would be nice to have them running automatically when we create a new PR for our project.</p><h3 id=adding-github-actions>Adding github actions<a hidden class=anchor aria-hidden=true href=#adding-github-actions>#</a></h3><p>This is really easy to setup, using <a href=https://actions-rs.github.io/>actions-rs</a>.</p><p>This project provides a toolkit of GitHub Action for Rust projects.</p><p>We need to create a <code>rust.yml</code> file in <code>.github/workflows/rust.yml</code></p><p>The yaml file will contain &ldquo;jobs&rdquo; for the cargo commands <code>check</code>, <code>test</code>, <code>fmt</code>, and <code>clippy</code>. This will make sure that all PRs made against our repo, are properly formatted, have passing test, and passing all standard rust linting checks.</p><p>The entire file is here
<a href=https://github.com/millerjam/rust_lambda_hello_world/blob/main/.github/workflows/rust.yml>https://github.com/millerjam/rust_lambda_hello_world/blob/main/.github/workflows/rust.yml</a></p><p>One you have committed this file into your github repo, you will see it populated in the <a href=https://github.com/millerjam/rust_lambda_hello_world/actions>&ldquo;Action&rdquo; tab</a></p><p><img loading=lazy src=/gh-action-pass-1.png alt="GitHub Action Passing"></p><p>Passing PRs will show a green check, and if any of the checks fail the PR will be marked as failed. And selecting the failed action will show the 4 jobs and which has failed</p><p><img loading=lazy src=/gh-action-failed-2.png alt="GitHub Action Failed"></p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>Now, we have a completed &ldquo;hello world&rdquo; lambda example. We created:</p><ol><li><a href=https://millerjam.github.io/posts/rust-lambda-hello-world/#add-the-code>An hello world lambda function</a></li><li><a href=https://millerjam.github.io/posts/rust-lambda-hello-world/#build-for-aws-lambda-install-x86-target>Cross compile the lambda</a></li><li><a href=https://millerjam.github.io/posts/rust-lambda-hello-world/#package-and-create-the-lambda>Deployed it into AWS</a></li><li><a href=https://millerjam.github.io/posts/rust-lambda-hello-world-logging/#lets-add-some-logging>Added logging</a></li><li><a href=https://millerjam.github.io/posts/rust-lambda-hello-world-tests/#writing-a-test>Added tests</a></li><li><a href=https://millerjam.github.io/posts/rust-lambda-hello-world-tests/#adding-github-actions>And finally, added continuous integration with GitHub Actions</a></li></ol><h4 id=final-github-project>Final GitHub Project<a hidden class=anchor aria-hidden=true href=#final-github-project>#</a></h4><p>You can reference the complete project here in my github repo <a href=https://github.com/millerjam/rust_lambda_hello_world>https://github.com/millerjam/rust_lambda_hello_world</a></p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://millerjam.github.io/>MillerJAM Site</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>