<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Rust Lambda Hello World | MillerJAM Site</title><meta name=keywords content>
<meta name=description content="Getting started with AWS Lambda Rust Runtime I just finished a quick tutorial to create a &ldquo;hello world&rdquo; lambda using AWS Lambda Rust Runtime
I think that Rust is a great fit for serverless and I wanted to start documenting how to use Rust in a lambda. Lambdas are a great opportunity to test out a new language without making a huge commitment in terms of time or resources. Additionally, the explicit connection between execution time and cost highlight the benefit of Rust&rsquo;s speed, both for for cold starts and warm execution time.">
<meta name=author content>
<link rel=canonical href=http://millerjam.github.io/posts/rust-lambda-hello-world/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://millerjam.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://millerjam.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://millerjam.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://millerjam.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://millerjam.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Rust Lambda Hello World">
<meta property="og:description" content="Getting started with AWS Lambda Rust Runtime I just finished a quick tutorial to create a &ldquo;hello world&rdquo; lambda using AWS Lambda Rust Runtime
I think that Rust is a great fit for serverless and I wanted to start documenting how to use Rust in a lambda. Lambdas are a great opportunity to test out a new language without making a huge commitment in terms of time or resources. Additionally, the explicit connection between execution time and cost highlight the benefit of Rust&rsquo;s speed, both for for cold starts and warm execution time.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://millerjam.github.io/posts/rust-lambda-hello-world/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-03-07T17:06:12-05:00">
<meta property="article:modified_time" content="2022-03-07T17:06:12-05:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Rust Lambda Hello World">
<meta name=twitter:description content="Getting started with AWS Lambda Rust Runtime I just finished a quick tutorial to create a &ldquo;hello world&rdquo; lambda using AWS Lambda Rust Runtime
I think that Rust is a great fit for serverless and I wanted to start documenting how to use Rust in a lambda. Lambdas are a great opportunity to test out a new language without making a huge commitment in terms of time or resources. Additionally, the explicit connection between execution time and cost highlight the benefit of Rust&rsquo;s speed, both for for cold starts and warm execution time.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://millerjam.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Rust Lambda Hello World","item":"http://millerjam.github.io/posts/rust-lambda-hello-world/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Lambda Hello World","name":"Rust Lambda Hello World","description":"Getting started with AWS Lambda Rust Runtime I just finished a quick tutorial to create a \u0026ldquo;hello world\u0026rdquo; lambda using AWS Lambda Rust Runtime\nI think that Rust is a great fit for serverless and I wanted to start documenting how to use Rust in a lambda. Lambdas are a great opportunity to test out a new language without making a huge commitment in terms of time or resources. Additionally, the explicit connection between execution time and cost highlight the benefit of Rust\u0026rsquo;s speed, both for for cold starts and warm execution time.","keywords":[],"articleBody":"Getting started with AWS Lambda Rust Runtime I just finished a quick tutorial to create a “hello world” lambda using AWS Lambda Rust Runtime\nI think that Rust is a great fit for serverless and I wanted to start documenting how to use Rust in a lambda. Lambdas are a great opportunity to test out a new language without making a huge commitment in terms of time or resources. Additionally, the explicit connection between execution time and cost highlight the benefit of Rust’s speed, both for for cold starts and warm execution time.\nBefore getting started here some prerequisites that you should already have working…\nPrerequisites  Install rust/cargo/etc Code editor AWS Account  Create a new rust binary Let’s get started with creating a new rust binary\ncargo new lambda_test Here I am using cargo to create a new binary with the name “lambda_test”. This will create a new directory and create a scaffold of a rust project.\nGetting started Now we are ready to get started writing our first lambda in rust. We will create a simple “hello world” lambda that will read an event that contains a first name, and respond with “Hello [first name].” Along the way we will cover writing the code, adding the crates, cross compiling for the lambda environment, deploying, and finally testing our code.\nLet’s get started…\nAdd the code To make this easy, we’ll copy the code from the AWS Lambda Rust Runtime README example. (Note: make sure you’ve selected the tag for version, v0.5 at the time I’m writing this) Copy the code snippet below, and replace the existing code in your project’s lambda_test/main.rs file.\nuse lambda_runtime::{service_fn, LambdaEvent, Error}; use serde_json::{json, Value};  #[tokio::main] async fn main() - Result(), Error {  let func = service_fn(func);  lambda_runtime::run(func).await?;  Ok(()) }  async fn func(event: LambdaEventValue) - ResultValue, Error {  let (event, _context) = event.into_parts();  let first_name = event[\"firstName\"].as_str().unwrap_or(\"world\");   Ok(json!({ \"message\": format!(\"Hello, {}!\", first_name) })) } This code has 2 methods. The main() which initializes some lambda related scaffolding. And the func(event: LambdaEvent) which is our code’s handler function. This is where all the business logic for our lambda lives.\nYou’ll notice that the AWS Lambda Rust Runtime uses tokio so the main function is preceded with a tokio macro and our handler function func needs to be async. The details of tokio are out of scope for this article. For now it is enough to just know it is an async framework used in some rust projects.\nFix the copy pasta errors Currently the lambda will not build, your IDE may show some errors related to crates not found.\nLets update the Cargo.toml with the required libraries.\nI use Cargo Edit which extends Cargo with commands to manage dependencies without having to manually edit your Cargo.toml\ncargo add lambda_runtime cargo add serde_json cargo add tokio Here we have added the AWS Lambda Rust Runtime, Serde JSON, and tokio\nFinally, the project should be ready to build.\nHow to build We will need to build a binary for the lambda environment, which might be different from our laptop. I’m using MacOS, so I’ll need to cross compile. If you are using linux you might be able to build for our target architecture without these extra steps. You are are using a mac, you can follow along to add the zig linker and appropriate target for the Lambda environment.\nCheck that normal local builds are working, and fix any dependency issues if needed. Before we get started with the cross compile steps, lets make sure a normal build works without and issues.\ncargo build Ok that should succeed and let us know that the code and dependencies are correct.\nBuild for AWS Lambda install x86 target We are going to target the “Amazon Linux2 x86” for our Lambda environment. In order to achieve this from a MacOS we will need to cross compile. The AWS Lambda Rust Runtime Github repo has instructions for cross compiling that we will follow here. They use zig and a cargo binary zigbuild to accomplish the build process.\n First install Zig  brew install zig Install cargo zigbuild  cargo install cargo-zigbuild Add the target for x86  rustup target add x86_64-unknown-linux-gnu Finally, we build the release  cargo zigbuild --release --target x86_64-unknown-linux-gnu Package and Create the Lambda Ok, now we have a binary that we can run on the AWS Lambda infrastructure. Next step, we need to bundle the binary and upload to our AWS account.\nCreate a zip archive In order to install and test our lambda, we are going to create a zip file with the binary. The binary is expected to have the name \"bootstrap\", so the following command renames it and creates a zip file that is ready to be uploaded to AWS.\ncp ./target/x86_64-unknown-linux-gnu/release/lambda_test ./bootstrap \u0026\u0026 zip lambda.zip bootstrap \u0026\u0026 rm bootstrap Create new function Note: Currently, I'm missing details about how to create the role and copy the ARN\nNow that we have the zip file with the “bootstrap” binary, we are ready to create a new lambda function. In the following command we use the aws cli to create a new lambda function with the name “rustTest”.\naws lambda create-function --function-name rustTest \\ --handler doesnt.matter \\ --zip-file fileb://./lambda.zip \\ --runtime provided.al2 \\ --role arn:aws:iam::{PUT_AWS_ACCT}:role/lambda_basic_execution \\ --environment Variables={RUST_BACKTRACE=1} \\ --tracing-config Mode=Active Note you will need to modify this command with your own \"--role\" name including account number.\nOnce we have run this command the new rust lambda function exists in our AWS account and we are ready to run a test.\nTest and Check the logs Test invoke We can invoke for testing directly from the cli using this cli command.\naws lambda invoke \\ --cli-binary-format raw-in-base64-out \\ --function-name rustTest \\ --payload '{\"firstName\": \"James\"}' \\ output.json Check output The output of the lambda is written to a file specified in the “invoke” command.\n cat output.json {\"message\":\"Hello, James!\"}% Check logs Note: would be good to add how to check cloudwatch logs from cli\nAfter invoking our “rustTest” lambda, we will want to check the cloudwatch logs and see the execution time.\nSTART RequestId: 2b0a5ad0 Version: $LATEST END RequestId: 2b0a5ad0 REPORT RequestId: 2b0a5ad0\tDuration: 0.85 ms\tBilled Duration: 1 ms\tMemory Size: 128 MB\tMax Memory Used: 15 MB\tXRAY TraceId: 1-6213be54\tSegmentId: 282cd\tSampled: true\tThe “hello world” lambda doesn’t do much, but it is still impressive to see a Billed Duration: 1 ms\nConclusions We were able to successfully create a Lambda using Rust! Using the AWS Lambda Rust Runtime made this easy, the code is straight forward. And using Zig made it easy to cross compile. The final result is a small binary that runs super fast.\nNext Time Next time, we will look at moving past “hello world” by adding some more functionality that we would need for any real world projects.\n","wordCount":"1135","inLanguage":"en","datePublished":"2022-03-07T17:06:12-05:00","dateModified":"2022-03-07T17:06:12-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://millerjam.github.io/posts/rust-lambda-hello-world/"},"publisher":{"@type":"Organization","name":"MillerJAM Site","logo":{"@type":"ImageObject","url":"http://millerjam.github.io/favicon.ico"}}}</script>
</head><body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://millerjam.github.io/ accesskey=h title="MillerJAM Site (Alt + H)">MillerJAM Site</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div><ul id=menu>
</ul></nav></header><main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Rust Lambda Hello World
</h1><div class=post-meta><span title="2022-03-07 17:06:12 -0500 -0500">March 7, 2022</span>
</div></header><div class=post-content><h2 id=getting-started-with-aws-lambda-rust-runtime>Getting started with AWS Lambda Rust Runtime<a hidden class=anchor aria-hidden=true href=#getting-started-with-aws-lambda-rust-runtime>#</a></h2><p>I just finished a quick tutorial to create a &ldquo;hello world&rdquo; lambda using
<a href=https://github.com/awslabs/aws-lambda-rust-runtime>AWS Lambda Rust Runtime</a></p><p>I think that Rust is a great fit for serverless and I wanted to start documenting how to use Rust in a lambda. Lambdas are a great opportunity to test out a new language without making a huge commitment in terms of time or resources. Additionally, the explicit connection between execution time and cost highlight the benefit of Rust&rsquo;s speed, both for for cold starts and warm execution time.</p><p>Before getting started here some prerequisites that you should already have working&mldr;</p><h2 id=prerequisites>Prerequisites<a hidden class=anchor aria-hidden=true href=#prerequisites>#</a></h2><ol>
<li>Install rust/cargo/etc</li><li>Code editor</li><li>AWS Account</li></ol><h2 id=create-a-new-rust-binary>Create a new rust binary<a hidden class=anchor aria-hidden=true href=#create-a-new-rust-binary>#</a></h2><p>Let&rsquo;s get started with creating a new rust binary</p><pre tabindex=0><code>cargo new lambda_test
</code></pre><p>Here I am using <code>cargo</code> to create a new binary with the name &ldquo;lambda_test&rdquo;. This will create a new directory and create a scaffold of a rust project.</p><h2 id=getting-started>Getting started<a hidden class=anchor aria-hidden=true href=#getting-started>#</a></h2><p>Now we are ready to get started writing our first lambda in rust. We will create a simple &ldquo;hello world&rdquo; lambda that will read an event that contains a first name, and respond with &ldquo;Hello [first name].&rdquo; Along the way we will cover writing the code, adding the crates, cross compiling for the lambda environment, deploying, and finally testing our code.</p><p>Let&rsquo;s get started&mldr;</p><h2 id=add-the-code>Add the code<a hidden class=anchor aria-hidden=true href=#add-the-code>#</a></h2><p>To make this easy, we&rsquo;ll copy the code from the <a href=https://github.com/awslabs/aws-lambda-rust-runtime/tree/v0.5.0>AWS Lambda Rust Runtime</a> README example. (Note: make sure you&rsquo;ve selected the tag for version, v0.5 at the time I&rsquo;m writing this) Copy the code snippet below, and replace the existing code in your project&rsquo;s <code>lambda_test/main.rs</code> file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> lambda_runtime::{service_fn, LambdaEvent, Error};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> serde_json::{json, Value};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> func <span style=color:#f92672>=</span> service_fn(func);
</span></span><span style=display:flex><span>    lambda_runtime::run(func).<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>func</span>(event: <span style=color:#a6e22e>LambdaEvent</span><span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Value, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (event, _context) <span style=color:#f92672>=</span> event.into_parts();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> first_name <span style=color:#f92672>=</span> event[<span style=color:#e6db74>&#34;firstName&#34;</span>].as_str().unwrap_or(<span style=color:#e6db74>&#34;world&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok(json<span style=color:#f92672>!</span>({ <span style=color:#e6db74>&#34;message&#34;</span>: <span style=color:#a6e22e>format</span><span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Hello, {}!&#34;</span>, first_name) }))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code has 2 methods. The <code>main()</code> which initializes some lambda related scaffolding. And the <code>func(event: LambdaEvent&lt;Value>)</code> which is our code&rsquo;s handler function. This is where all the business logic for our lambda lives.</p><p>You&rsquo;ll notice that the <a href=https://github.com/awslabs/aws-lambda-rust-runtime/tree/v0.5.0>AWS Lambda Rust Runtime</a> uses <a href=https://tokio.rs/>tokio</a> so the <code>main</code> function is preceded with a tokio macro and our handler function <code>func</code> needs to be <code>async</code>. The details of tokio are out of scope for this article. For now it is enough to just know it is an async framework used in some rust projects.</p><h2 id=fix-the-copy-pasta-errors>Fix the copy pasta errors<a hidden class=anchor aria-hidden=true href=#fix-the-copy-pasta-errors>#</a></h2><p>Currently the lambda will not build, your IDE may show some errors related to crates not found.</p><p>Lets update the <code>Cargo.toml</code> with the required libraries.</p><p>I use <a href=https://github.com/killercup/cargo-edit>Cargo Edit</a> which extends Cargo with commands to manage dependencies without having to manually edit your <code>Cargo.toml</code></p><pre tabindex=0><code>cargo add lambda_runtime

cargo add serde_json

cargo add tokio
</code></pre><p>Here we have added the <a href=https://github.com/awslabs/aws-lambda-rust-runtime/tree/v0.5.0>AWS Lambda Rust Runtime</a>, <a href=https://github.com/serde-rs/json>Serde JSON</a>, and <a href=https://tokio.rs/>tokio</a></p><p>Finally, the project should be ready to build.</p><h2 id=how-to-build>How to build<a hidden class=anchor aria-hidden=true href=#how-to-build>#</a></h2><p>We will need to build a binary for the lambda environment, which might be different from our laptop. I&rsquo;m using MacOS, so I&rsquo;ll need to cross compile. If you are using linux you might be able to build for our target architecture without these extra steps. You are are using a mac, you can follow along to add the zig linker and appropriate target for the Lambda environment.</p><h3 id=check-that-normal-local-builds-are-working-and-fix-any-dependency-issues-if-needed>Check that normal local builds are working, and fix any dependency issues if needed.<a hidden class=anchor aria-hidden=true href=#check-that-normal-local-builds-are-working-and-fix-any-dependency-issues-if-needed>#</a></h3><p>Before we get started with the cross compile steps, lets make sure a normal build works without and issues.</p><pre tabindex=0><code>cargo build
</code></pre><p>Ok that should succeed and let us know that the code and dependencies are correct.</p><h3 id=build-for-aws-lambda-install-x86-target>Build for AWS Lambda install x86 target<a hidden class=anchor aria-hidden=true href=#build-for-aws-lambda-install-x86-target>#</a></h3><p>We are going to target the &ldquo;Amazon Linux2 x86&rdquo; for our Lambda environment. In order to achieve this from a MacOS we will need to cross compile. The <a href=https://github.com/awslabs/aws-lambda-rust-runtime/tree/v0.5.0#1-cross-compiling-your-lambda-functions>AWS Lambda Rust Runtime</a> Github repo has instructions for cross compiling that we will follow here. They use <code>zig</code> and a cargo binary <code>zigbuild</code> to accomplish the build process.</p><ol>
<li>First install <a href=https://ziglang.org/>Zig</a></li></ol><pre tabindex=0><code>brew install zig
</code></pre><ol start=2>
<li>Install cargo <a href=https://github.com/messense/cargo-zigbuild>zigbuild</a></li></ol><pre tabindex=0><code>cargo install cargo-zigbuild
</code></pre><ol start=3>
<li>Add the target for x86</li></ol><pre tabindex=0><code>rustup target add x86_64-unknown-linux-gnu
</code></pre><ol start=4>
<li>Finally, we build the release</li></ol><pre tabindex=0><code>cargo zigbuild --release --target x86_64-unknown-linux-gnu
</code></pre><h2 id=package-and-create-the-lambda>Package and Create the Lambda<a hidden class=anchor aria-hidden=true href=#package-and-create-the-lambda>#</a></h2><p>Ok, now we have a binary that we can run on the AWS Lambda infrastructure. Next step, we need to bundle the binary and upload to our AWS account.</p><h3 id=create-a-zip-archive>Create a zip archive<a hidden class=anchor aria-hidden=true href=#create-a-zip-archive>#</a></h3><p>In order to install and test our lambda, we are going to create a zip file with the binary. The binary is expected to have the name <code>"bootstrap"</code>, so the following command renames it and creates a zip file that is ready to be uploaded to AWS.</p><pre tabindex=0><code>cp ./target/x86_64-unknown-linux-gnu/release/lambda_test ./bootstrap &amp;&amp; zip lambda.zip bootstrap &amp;&amp; rm bootstrap
</code></pre><h3 id=create-new-function>Create new function<a hidden class=anchor aria-hidden=true href=#create-new-function>#</a></h3><p><code>Note: Currently, I'm missing details about how to create the role and copy the ARN</code></p><p>Now that we have the zip file with the &ldquo;bootstrap&rdquo; binary, we are ready to create a new lambda function. In the following command we use the <code>aws</code> cli to create a new lambda function with the name &ldquo;rustTest&rdquo;.</p><pre tabindex=0><code>aws lambda create-function --function-name rustTest \
  --handler doesnt.matter \
  --zip-file fileb://./lambda.zip \
  --runtime provided.al2 \
  --role arn:aws:iam::{PUT_AWS_ACCT}:role/lambda_basic_execution \
  --environment Variables={RUST_BACKTRACE=1} \
  --tracing-config Mode=Active
</code></pre><p><code>Note</code> you will need to modify this command with your own <code>"--role"</code> name including account number.</p><p>Once we have run this command the new rust lambda function exists in our AWS account and we are ready to run a test.</p><h2 id=test-and-check-the-logs>Test and Check the logs<a hidden class=anchor aria-hidden=true href=#test-and-check-the-logs>#</a></h2><h3 id=test-invoke>Test invoke<a hidden class=anchor aria-hidden=true href=#test-invoke>#</a></h3><p>We can invoke for testing directly from the cli using this cli command.</p><pre tabindex=0><code>aws lambda invoke \
  --cli-binary-format raw-in-base64-out \
  --function-name rustTest \
  --payload &#39;{&#34;firstName&#34;: &#34;James&#34;}&#39; \
  output.json
</code></pre><h3 id=check-output>Check output<a hidden class=anchor aria-hidden=true href=#check-output>#</a></h3><p>The output of the lambda is written to a file specified in the &ldquo;invoke&rdquo; command.</p><pre tabindex=0><code>&gt; cat output.json
{&#34;message&#34;:&#34;Hello, James!&#34;}%
</code></pre><h3 id=check-logs>Check logs<a hidden class=anchor aria-hidden=true href=#check-logs>#</a></h3><p><code>Note: would be good to add how to check cloudwatch logs from cli</code></p><p>After invoking our &ldquo;rustTest&rdquo; lambda, we will want to check the cloudwatch logs and see the execution time.</p><pre tabindex=0><code>START RequestId: 2b0a5ad0
Version: $LATEST
END RequestId: 2b0a5ad0
REPORT RequestId: 2b0a5ad0	Duration: 0.85 ms	Billed Duration: 1 ms	Memory Size: 128 MB	Max Memory Used: 15 MB	
XRAY TraceId: 1-6213be54	SegmentId: 282cd	Sampled: true	
</code></pre><p>The &ldquo;hello world&rdquo; lambda doesn&rsquo;t do much, but it is still impressive to see a <code>Billed Duration: 1 ms</code></p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>We were able to successfully create a Lambda using Rust! Using the <a href=https://github.com/awslabs/aws-lambda-rust-runtime>AWS Lambda Rust Runtime</a> made this easy, the code is straight forward. And using Zig made it easy to cross compile. The final result is a small binary that runs super fast.</p><h3 id=next-time>Next Time<a hidden class=anchor aria-hidden=true href=#next-time>#</a></h3><p>Next time, we will look at moving past &ldquo;hello world&rdquo; by adding some more functionality that we would need for any real world projects.</p></div><footer class=post-footer>
</footer></article></main><footer class=footer>
<span>&copy; 2022 <a href=http://millerjam.github.io/>MillerJAM Site</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script>
</body></html>